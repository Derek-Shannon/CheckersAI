# checkers/scenes/game_scene.py
import pygame
import math, random # math/random might not be needed if Board and AI are separated
from .scene import Scene
from ..game.board import Board
from ..ai import minmax # Import the AI module
from ..data.timer import Timer # Assuming Timer is available

class GameScene(Scene):
    def __init__(self, screen, mode='PvP'):
        super().__init__(screen)
        self.mode = mode
        self.board_manager = Board() # Instantiate the Board Model
        self.AITimer = Timer(500)
        
        # Pygame constants, image loading, UI setup remain here
        # ... (Image loading, SCREEN_WIDTH, BOARD_SIZE, BUTTON setup, Fonts) ...

        # Game State (now references the Board object)
        self.current_turn = self.board_manager.current_turn
        self.selected_piece = None # Stores the (row, col) of the selected piece
        self.valid_moves = {}      # Maps valid move (row, col) to captured piece (or None)
        self.status_message = f"It's {self.current_turn}'s turn."
        self.game_over = False

    # --- Coordinate Conversion (Stays here as it's screen-dependent) ---
    # _get_board_coords, _get_pixel_coords

    # --- Event Handling (Controller) ---
    def handle_event(self, event):
        # ... (Back button logic) ...
        # ... (Board click logic) ...
        
        if self.selected_piece and target_rc in self.valid_moves:
            # Get the piece and move info
            piece_rc = self.selected_piece
            captured_piece = self.valid_moves[target_rc]
            
            # Delegate movement to the Board Model
            must_multijump, status_msg = self.board_manager.move_piece(piece_rc, target_rc, captured_piece)
            self.status_message = status_msg
            
            if must_multijump:
                # Re-select the piece and calculate new jumps
                piece = self.board_manager._get_piece_at(target_rc[0], target_rc[1])
                self.selected_piece = target_rc
                self.valid_moves = self.board_manager._check_jump_moves(piece)
            else:
                self.selected_piece = None
                self.valid_moves = {}
                self.current_turn = self.board_manager.current_turn
                
            # Check for game over
            msg, is_over = self.board_manager.get_game_state()
            if is_over:
                self.game_over = True
                self.status_message = msg

    # --- AI Control (Controller) ---
    def runAI(self):
        if self.current_turn == "Black" and not self.game_over:
            depth = 5 
            # Pass the board's internal state to the MinMax algorithm
            best_val, best_move = minmax.minmax(self.board_manager.board, depth, True)
            
            if best_move:
                piece_rc, target_rc, captured_piece = best_move
                must_multijump, status_msg = self.board_manager.move_piece(piece_rc, target_rc, captured_piece)
                # ... handle multi-jump and end turn logic (similar to human move) ...
                self.current_turn = self.board_manager.current_turn
                self.status_message = status_msg
            # ... (rest of runAI logic) ...

    # --- Update/Draw Methods (View) ---
    # draw_board, draw_pieces, draw_indicators, draw_ui_elements, draw, update
    # These methods access self.board_manager.board and self.board_manager.taken_pieces
    # ... (Drawing logic) ...